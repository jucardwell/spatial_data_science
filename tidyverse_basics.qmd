# Basic R

This chapter will introduce you to the basics of working with base R. After completing these exercises, you should be able to:

-   Create a .Rmd and save it to your GEOG215 folder
-   Use basic text and chunk formatting to create a readable knitted .Rmd file (.html)
-   Read in data using a relative file path
-   Execute the basics of base R by creating comments, assigning objects, and using base R functions

We will use the following datasets:

-   Data on chronic school absence rate for North Carolina Public Schools before and after the Covid-19 pandemic from the [North Carolina Department of Public Instruction](https://www.dpi.nc.gov/data-reports/school-report-cards/school-report-card-resources-researchers)
-   North Carolina census tract rurality definitions (RUCA codes) from the [USDA Economic Research Service](https://www.ers.usda.gov/data-products/rural-urban-commuting-area-codes) and the [NC Rural Center](https://www.ncruralcenter.org/)**.** RUCA codes establish urban cores and the census tracts that are the most economically integrated with those cores through commuting. The NC Rural Center defines rurality as areas with less than 250 residents per square mile.

```{r, include=FALSE}

library(tidyverse)

absences <- read_csv("https://drive.google.com/uc?export=download&id=1cDHtaBhZpTwTct77f53kSmurSNG4hAI-")

rurality <- read_csv("nc_rurality_tracts.csv")

```

## Creating a .Rmd and Reading Data

To follow along with this tutorial, you should create a new .Rmd document and save it into your GEOG215 folder. Once you've saved it, close the file and re-open it. **Every time you see code below, you should copy it to your own document!**

**Q1: Once you re-open the folder, what is your current working directory? How do you know?**

Remove all the code chunks except for the setup chunk. Below the setup chunk add a "first-level header" called "Loading Libraries and Reading in Data".

![](images/clipboard-3717346850.png)

Then add a chunk below this text and load the tidyverse package. Format that chunk so that it is not included in the knitted document.

You will read in the school absence data directly from Google Drive using the following command:

`absences <- read_csv("https://drive.google.com/uc?export=download&id=1yH50dkdLLPx0AiHbvzWoLtSSnIY-1moh")`

To practice reading in data locally, download the [NC Rurality Data](https://drive.google.com/uc?export=download&id=1eQ8UbyoCGNWlo4uTmKvzi40pAhL_54rO) to your GEOG215 folder (or whatever subfolder you have your .Rmd file saved to). Then, write a relative file path to read in that file. You will use the command

`rurality <- read_csv("RELATIVEFILEPATH")`

Your .Rmd should now look something like this

![](images/clipboard-3987952332.png)

## Running Chunks and Knitting

We have completed our code chunk for loading libraries and reading in data. Now we can"Run" or evaluate that code. We can evaluate a code chunk by clicking the green arrow. Once you've evaluated the chunk, the datasets should show up in your Environment. Those are now "Objects"

![](images/clipboard-1977768479.png)

Now practice knitting your document using the Knit button on the top panel. This should create a new .html file that will be saved in your working directory. The file will open in a new window.

![](images/clipboard-1659240099.png)

**Q2: Why does the knitted document not include our code?**

## Basic R Commands

Add a new first level header called "Practicing Basic R Commands". Then add a code chunk below that.

### Making Comments

Any time you write a command, you will want to include a descriptive comment above it. To make a comment, we use this formatting.

```{r}
## this is a comment
```

### Basic Math

Add the following commands to your code chunk. In addition to running a full chunk, you can also run a single line of code by clicking "Command" and "Return" on a Mac or "Control" and "Enter" on a PC. Run each of the following commands.

```{r, eval=F}
## basic addition
4 + 3

## basic division
123.1 / 3.445

##exponents
5^2

```

**Q3: Where is the output printed when you run those commands?**

### Boolean Operators

Boolean logical operators return either a true or a false based on the conditions. Add these commands to your code chunk and run each one.

```{r, eval=F}
## is greater? 
2 > 5

## is equal? 
3 == 3

## is greater or equal? 
10000 >= 1

## is less? 
(3 * 5) < 20
```

### Functions

Functions can be though of as "actions". Base R already has many built in functions. The basic setup of a function is `function(argument, ...)`. Add these commands to your code chunk and run each one.

```{r, eval=F}

#sum
sum(2:963)

#sum
mean(c(1, 10, 100, NA))

#sum, remove na
mean(c(1, 10, 100, NA), na.rm = TRUE)

```

## Assigning and Printing Objects

So far, every command weâ€™ve run has been *evaluated in the console*, which means R immediately prints the result at the bottom of the chunk. This happens any time you type an expression without saving it as an object.

Saving as an object means that the result of that command is stored in our environment (like the data we read in). To create objects, we use the `<-` command. To see the output in the console, you need to print the object. The benefit of using objects is that we can "call" that object in later commands without having to rewrite the whole command over again. Add these commands to your code chunk and run each one.

```{r, eval = F}
## save an object
math_object <- 4 + 3

## print an object
math_object

```

## Data Types

R works with several fundamental data types. Remember that the data type has to do with the data *values:*

-   Numeric: numbers with decimals
-   Integer: whole numbers
-   Character: text data (strings)
-   Logical: True/False values
-   Factor: Categorical data with predefined levels
-   NA: Missing data

You can check the data type using the `class()` command. Add these objects to your code chunk. Then write a command to check the data type of each object.

```{r, eval = F}

x <- 5

y <- 10L #R stores numbers as numeric, unless you specify

text <- "North Carolina" #Try running this without the quotations

sample <- "10" #try adding sample to x. What happens? Why? 

logical <- 3 > 1

rural <- factor(c("Urban", "Rural"))

```

**Q4: What happens if you values are not the expected data type? For instance, if you wanted to add sample to x?**

## Data Structures

R organizes data into several common structures. These structures determine how values are stored and how you can work with them. Remember that data structure has to do with how values (of any type) are *stored*

-   Vector: Collection of items that are all the same data type
-   List: Collection of items that can be different data types
-   Matrix: Two-dimensional table of values, all of the same data type
-   Data Frame: Two-dimensional table where columns can be different data types

You can check the structure of any object using the `str()` command. Add the following objects to your chunk and check the structure of each:

```{r, eval = F}

v <- c(1, 5, 10, 20) #note that c() is used to combine

l <- list(1, "NC", TRUE)

m <- matrix(1:6, nrow = 2)

df <- data.frame(a = 1:3, b = c("x", "y", "z"))

```

## Indexing and Subsetting

Indexing is used to select or subset elements from data structures.

-   `[]` selects elements by position
-   `[[]]` extracts a single element
-   `$` extracts a column by name
-   Logical indexing selects elements that meet a condition

Add these commands to your chunk. Run each command and add a comment based on what the command is doing.

```{r, eval = F}

#practice df (I made these values up!)
nc_example <- data.frame(
  county = c("Wake", "Durham", "Orange", "Buncombe", "Mecklenburg"),
  population = c(1130000, 330000, 150000, 270000, 1135000),
  region = factor(c("Piedmont", "Piedmont", "Piedmont", "Mountain", "Piedmont")),
  pct_rural = c(0.03, 0.07, 0.28, 0.35, 0.02),
  has_university = c(TRUE, TRUE, TRUE, FALSE, TRUE)
)

#
nc_example[1, ]  

#
nc_example[, 2]

#
nc_example[3, 1] 

#
nc_example[2:4, 3]

#
nc_example$population

#
nc_example[["population"]]

#
nc_example[nc_example$population > 300000, ]

```

## Creating a New Variable

We can create new variables using the `$` command. Add this command and a descriptive comment

```{r, eval = F}
#
nc_example$pct_urban = 1 - nc_example$pct_rural

```

## Mini-Challenge 

Add a new first level header called "Mini-Challenge #1". Under that header, add a code chunk. In the code chunk, write commands to do the following:

-   Add a variable to the nc_example data frame called "pop_million" that calculates the population of each county in millions
-   Using the nc_example data frame, create a new object called triangle_region that contains only the counties located in the Piedmont region.
-   Extract the pct_rural value for Orange County
-   Using the triangle-region object you created, calculate and print the mean population of the Triangle counties
-   Create a new object called very_rural that returns a filtered data frame containing only counties where more than 20% of the population is rural
